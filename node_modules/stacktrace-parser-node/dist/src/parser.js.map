{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../src/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { ErrorResponse, SourceCode, Trace } from \"./types\";\nimport { promises, existsSync } from \"fs\";\n\nconst MAX_CODE_LINES = 6;\nconst LINE_REGEXP = /at (.+?)\\s+\\((?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)/;\n\nconst parse = async (error: Error): Promise<ErrorResponse> => {\n  const { message, name, stack } = error;\n\n  const traces = await parseTraces(stack || \"\");\n\n  return {\n    message,\n    name,\n    traces,\n  };\n};\n\nconst parseTraces = async (stack: string): Promise<Trace[]> => {\n  const traces: Trace[] = [];\n\n  if (!stack.length) {\n    return [];\n  }\n\n  const stacktraces = stack.split(\"\\n\").slice(1);\n  for (const line of stacktraces) {\n    const trace = await createTrace(line);\n    if (trace) {\n      traces.push(trace);\n    }\n  }\n\n  return (\n    traces.slice(0, 25).map((trace) => ({\n      ...trace,\n    })) || []\n  );\n};\n\nconst createTrace = async (line: string): Promise<Trace | undefined> => {\n  const lineMatch = line.match(LINE_REGEXP);\n  if (!lineMatch) {\n    return undefined;\n  }\n\n  let functionName: string | undefined;\n  let extension: string | undefined;\n\n  if (!lineMatch || lineMatch[0].includes(\"<anonymous>\")) {\n    return undefined;\n  }\n\n  if (lineMatch[1]) {\n    functionName = lineMatch[1];\n  }\n\n  const path = lineMatch[2]?.startsWith(\"file://\")\n    ? lineMatch[2].substr(7)\n    : lineMatch[2];\n  const internal =\n    path !== undefined &&\n    !path.includes(\"node_modules/\") &&\n    !path.includes(\"node_modules\\\\\") &&\n    !path.includes(\"internal/\");\n\n  const filename = lineMatch[2]?.startsWith('file://') ? lineMatch[2].substr(7) : lineMatch[2];\n\n  if (filename) {\n    const splitedFilename = filename?.split(\".\");\n    extension = splitedFilename[splitedFilename.length - 1];\n  }\n\n  const lineNo = parseInt(lineMatch[3], 10);\n\n  const code = await getSourceCode(path, lineNo);\n\n  const properties = {\n    filename: parseFilename(filename),\n    function: functionName,\n    absPath: path,\n    lineNo,\n    columnNo: parseInt(lineMatch[4], 10) || undefined,\n    internal,\n    extension,\n    ...code,\n  };\n\n  return properties;\n};\n\nconst getSourceCode = async (\n  path: string,\n  lineNumber: number\n): Promise<SourceCode | undefined> => {\n  const context = await readFileContext(path);\n  if (!context) {\n    return undefined;\n  }\n\n  const linesOfCode: string[] = context?.split(\"\\n\");\n\n  const code: string = linesOfCode[lineNumber - 1];\n  const preCode: string[] = linesOfCode.slice(\n    lineNumber - MAX_CODE_LINES,\n    lineNumber - 1\n  );\n  const postCode: string[] = linesOfCode.slice(\n    lineNumber,\n    lineNumber + MAX_CODE_LINES\n  );\n\n  return {\n    code,\n    preCode,\n    postCode,\n  };\n};\n\nconst readFileContext = async (path: string): Promise<string> => {\n  let context = \"\";\n\n  const isExists = existsSync(path);\n  if (isExists) {\n    context = await promises.readFile(path, \"utf8\");\n  }\n\n  return context;\n};\n\nconst parseFilename = (filename: string): string => {\n  const splits = filename.split(\"\\\\\");\n  const searchvalues = [\"node_modules\", \"dist\", \"build\", \"lib\"];\n\n  let index = undefined;\n\n  for (const search of searchvalues) {\n    if (index && index !== -1) {\n      continue;\n    }\n\n    if (splits.indexOf(search) !== -1) {\n      index = splits.indexOf(search);\n    }\n  }\n\n  if (!index) {\n    return filename;\n  }\n\n  const slices = splits.slice(index, splits.length);\n  const response = \"...\\\\\" + slices.join(\"\\\\\");\n\n  return response;\n}\n\nexport const stacktrace = {\n  parse,\n};\n"]}