var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
exports.stacktrace = void 0;
var tslib_1 = require("tslib");
var fs_1 = require("fs");
var MAX_CODE_LINES = 6;
var LINE_REGEXP = /at (.+?)\s+\((?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)/;
var parse = function (error) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    var message, name, stack, traces;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                message = error.message, name = error.name, stack = error.stack;
                return [4 /*yield*/, parseTraces(stack || "")];
            case 1:
                traces = _a.sent();
                return [2 /*return*/, {
                        message: message,
                        name: name,
                        traces: traces,
                    }];
        }
    });
}); };
var parseTraces = function (stack) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    var traces, stacktraces, stacktraces_1, stacktraces_1_1, line, trace, e_1_1;
    var e_1, _a;
    return tslib_1.__generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                traces = [];
                if (!stack.length) {
                    return [2 /*return*/, []];
                }
                stacktraces = stack.split("\n").slice(1);
                _b.label = 1;
            case 1:
                _b.trys.push([1, 6, 7, 8]);
                stacktraces_1 = tslib_1.__values(stacktraces), stacktraces_1_1 = stacktraces_1.next();
                _b.label = 2;
            case 2:
                if (!!stacktraces_1_1.done) return [3 /*break*/, 5];
                line = stacktraces_1_1.value;
                return [4 /*yield*/, createTrace(line)];
            case 3:
                trace = _b.sent();
                if (trace) {
                    traces.push(trace);
                }
                _b.label = 4;
            case 4:
                stacktraces_1_1 = stacktraces_1.next();
                return [3 /*break*/, 2];
            case 5: return [3 /*break*/, 8];
            case 6:
                e_1_1 = _b.sent();
                e_1 = { error: e_1_1 };
                return [3 /*break*/, 8];
            case 7:
                try {
                    if (stacktraces_1_1 && !stacktraces_1_1.done && (_a = stacktraces_1.return)) _a.call(stacktraces_1);
                }
                finally { if (e_1) throw e_1.error; }
                return [7 /*endfinally*/];
            case 8: return [2 /*return*/, (traces.slice(0, 25).map(function (trace) { return (tslib_1.__assign({}, trace)); }) || [])];
        }
    });
}); };
var createTrace = function (line) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    var lineMatch, functionName, extension, path, internal, filename, splitedFilename, lineNo, code, properties;
    var _a, _b;
    return tslib_1.__generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                lineMatch = line.match(LINE_REGEXP);
                if (!lineMatch) {
                    return [2 /*return*/, undefined];
                }
                if (!lineMatch || lineMatch[0].includes("<anonymous>")) {
                    return [2 /*return*/, undefined];
                }
                if (lineMatch[1]) {
                    functionName = lineMatch[1];
                }
                path = ((_a = lineMatch[2]) === null || _a === void 0 ? void 0 : _a.startsWith("file://"))
                    ? lineMatch[2].substr(7)
                    : lineMatch[2];
                internal = path !== undefined &&
                    !path.includes("node_modules/") &&
                    !path.includes("node_modules\\") &&
                    !path.includes("internal/");
                filename = ((_b = lineMatch[2]) === null || _b === void 0 ? void 0 : _b.startsWith('file://')) ? lineMatch[2].substr(7) : lineMatch[2];
                if (filename) {
                    splitedFilename = filename === null || filename === void 0 ? void 0 : filename.split(".");
                    extension = splitedFilename[splitedFilename.length - 1];
                }
                lineNo = parseInt(lineMatch[3], 10);
                return [4 /*yield*/, getSourceCode(path, lineNo)];
            case 1:
                code = _c.sent();
                properties = tslib_1.__assign({ filename: parseFilename(filename), function: functionName, absPath: path, lineNo: lineNo, columnNo: parseInt(lineMatch[4], 10) || undefined, internal: internal, extension: extension }, code);
                return [2 /*return*/, properties];
        }
    });
}); };
var getSourceCode = function (path, lineNumber) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    var context, linesOfCode, code, preCode, postCode;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, readFileContext(path)];
            case 1:
                context = _a.sent();
                if (!context) {
                    return [2 /*return*/, undefined];
                }
                linesOfCode = context === null || context === void 0 ? void 0 : context.split("\n");
                code = linesOfCode[lineNumber - 1];
                preCode = linesOfCode.slice(lineNumber - MAX_CODE_LINES, lineNumber - 1);
                postCode = linesOfCode.slice(lineNumber, lineNumber + MAX_CODE_LINES);
                return [2 /*return*/, {
                        code: code,
                        preCode: preCode,
                        postCode: postCode,
                    }];
        }
    });
}); };
var readFileContext = function (path) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    var context, isExists;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                context = "";
                isExists = (0, fs_1.existsSync)(path);
                if (!isExists) return [3 /*break*/, 2];
                return [4 /*yield*/, fs_1.promises.readFile(path, "utf8")];
            case 1:
                context = _a.sent();
                _a.label = 2;
            case 2: return [2 /*return*/, context];
        }
    });
}); };
var parseFilename = function (filename) {
    var e_2, _a;
    var splits = filename.split("\\");
    var searchvalues = ["node_modules", "dist", "build", "lib"];
    var index = undefined;
    try {
        for (var searchvalues_1 = tslib_1.__values(searchvalues), searchvalues_1_1 = searchvalues_1.next(); !searchvalues_1_1.done; searchvalues_1_1 = searchvalues_1.next()) {
            var search = searchvalues_1_1.value;
            if (index && index !== -1) {
                continue;
            }
            if (splits.indexOf(search) !== -1) {
                index = splits.indexOf(search);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (searchvalues_1_1 && !searchvalues_1_1.done && (_a = searchvalues_1.return)) _a.call(searchvalues_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (!index) {
        return filename;
    }
    var slices = splits.slice(index, splits.length);
    var response = "...\\" + slices.join("\\");
    return response;
};
exports.stacktrace = {
    parse: parse,
};
//# sourceMappingURL=parser.js.map